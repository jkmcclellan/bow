<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Bow</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Bow is a library for Typed Functional Programming in Swift">
    <meta name="keywords" content="functional-programming, swift-library, monads, monad-transformers, functional-data-structure, swift, fp-types, adt, free-monads, tagless-final, mtl, for-comprehension, category-theory">

    <meta property="og:image" content="" />
    <meta property="og:title" content="Bow" />
    <meta property="og:site_name" content="Bow" />
    <meta property="og:url" content="https://bow-swift.io" />
    <meta property="og:type" content="website" />
    <meta property="og:description" content="Bow is a library for Typed Functional Programming in Swift" />
    <meta property="og:keywords" content="functional-programming, swift-library, monads, monad-transformers, functional-data-structure, swift, fp-types, adt, free-monads, tagless-final, mtl, for-comprehension, category-theory" />

    <meta name="twitter:text:description" content="Bow is a library for Typed Functional Programming in Swift" />
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@bow_swift">
    <meta name="twitter:creator" content="@bow_swift">
    <meta name="twitter:image" content="https://bow-swift.io/img/twitter-card.png" />

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">

    <!-- Favicon -->
    <link rel="shortcut icon" href="/0.4.0/img/favicon.png">
    <!-- Main css -->
    <link rel="stylesheet" type="text/css" href="/0.4.0/css/docs.css">
    <!-- Highlighting css -->
    <link rel="stylesheet" type="text/css" href="/0.4.0/api-docs/css/highlight.css">

    
        <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-18433785-19"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-18433785-19');
</script>

    

</head>

<body id="doc-body">
<div id="wrapper">
    <div id="sidebar-wrapper">
    <div class="sidebar-brand">
        <a class="brand" href="/">
            <img src="/img/icon.svg" alt="">
            <span>Bow</span>
        </a>
        <button type="button" id="main-toggle" class="sidebar-toggle">
            <span class="close"></span>
        </button>
    </div>

    <ul class="sidebar-nav">
        
        <li class="sidebar-nav-item">
            <a href="#">
                <span>Quick start</span>
                
                <i class="fa fa-angle-right"></i>
                
            </a>
            
            <ul>
                
                <li>
                    <a href="/docs/quick-start/getting-started/">
                        <i class="fa fa-circle"></i>
                        <span>Getting started</span>
                    </a>
                </li>
                
                <li>
                    <a href="/docs/quick-start/modules/">
                        <i class="fa fa-circle"></i>
                        <span>Modules</span>
                    </a>
                </li>
                
                <li>
                    <a href="/docs/quick-start/resources/">
                        <i class="fa fa-circle"></i>
                        <span>Resources</span>
                    </a>
                </li>
                
            </ul>
            
        </li>
        
        <li class="sidebar-nav-item">
            <a href="#">
                <span>FP concepts</span>
                
                <i class="fa fa-angle-right"></i>
                
            </a>
            
            <ul>
                
                <li>
                    <a href="/docs/fp-concepts/glossary/">
                        <i class="fa fa-circle"></i>
                        <span>Glossary</span>
                    </a>
                </li>
                
                <li>
                    <a href="/docs/fp-concepts/functions-vs-procedures/">
                        <i class="fa fa-circle"></i>
                        <span>Functions vs Procedures</span>
                    </a>
                </li>
                
                <li>
                    <a href="/docs/fp-concepts/higher-kinded-types/">
                        <i class="fa fa-circle"></i>
                        <span>Higher Kinded Types</span>
                    </a>
                </li>
                
                <li>
                    <a href="/docs/fp-concepts/type-classes/">
                        <i class="fa fa-circle"></i>
                        <span>Type classes</span>
                    </a>
                </li>
                
                <li>
                    <a href="/docs/fp-concepts/data-types/">
                        <i class="fa fa-circle"></i>
                        <span>Data types</span>
                    </a>
                </li>
                
            </ul>
            
        </li>
        
        <li class="sidebar-nav-item">
            <a href="#">
                <span>Patterns</span>
                
                <i class="fa fa-angle-right"></i>
                
            </a>
            
            <ul>
                
                <li>
                    <a href="/docs/patterns/error-handling/">
                        <i class="fa fa-circle"></i>
                        <span>Error handling</span>
                    </a>
                </li>
                
                <li>
                    <a href="/docs/patterns/dependency-injection/">
                        <i class="fa fa-circle"></i>
                        <span>Dependency injection</span>
                    </a>
                </li>
                
                <li>
                    <a href="/docs/patterns/polymorphic-programs/">
                        <i class="fa fa-circle"></i>
                        <span>Polymorphic programs</span>
                    </a>
                </li>
                
            </ul>
            
        </li>
        
        <li class="sidebar-nav-item">
            <a href="#">
                <span>Legal</span>
                
                <i class="fa fa-angle-right"></i>
                
            </a>
            
            <ul>
                
                <li>
                    <a href="/docs/legal/credits/">
                        <i class="fa fa-circle"></i>
                        <span>Credits</span>
                    </a>
                </li>
                
                <li>
                    <a href="/docs/legal/license/">
                        <i class="fa fa-circle"></i>
                        <span>License</span>
                    </a>
                </li>
                
            </ul>
            
        </li>
        
    </ul>
</div>

    <div id="doc-wrapper">
    <div class="doc-header">
        <button type="button" id="main-toggle" class="sidebar-toggle">
            <i class="fa fa-lg fa-bars menu-icon"></i>
        </button>
        <a target="_blank"
          href="https://github.com/bow-swift/bow/edit/master/docs/docs/fp-concepts/higher-kinded-types/README.md">
          <i class="fa fa-pencil"></i>
            Edit
        </a>
    </div>
    <div class="doc-content">
        <h1 id="higher-kinded-types">Higher Kinded Types</h1>

<p class="beginner">beginner</p>

<p>Swift does not support Higher Kinded Types (HKTs) yet, although the <a href="https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#higher-kinded-types">Generics Manifesto</a> states there are plans to support them natively. However, HKTs are essential to enable Functional Programming with type classes and polymorphism. For this reason, Bow provides lightweight emulation support of HKTs. This document describes how this feature is implemented in Bow and how you can use it to create your own types with HKT support.</p>

<h2 id="motivation">Motivation</h2>

<p>Swift provides support for generic programming, so that we do not have to rewrite the same logic for multiple types. For instance, consider the following two functions:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">allIntsEqual</span><span class="p">(</span><span class="n">_</span> <span class="nv">array</span><span class="p">:</span> <span class="p">[</span><span class="kt">Int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="p">{</span>
    <span class="k">guard</span> <span class="k">let</span> <span class="nv">first</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">first</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">false</span> <span class="p">}</span>
    <span class="k">return</span> <span class="n">array</span><span class="o">.</span><span class="nf">reduce</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span> <span class="n">partial</span><span class="p">,</span> <span class="n">next</span> <span class="k">in</span> <span class="n">partial</span> <span class="o">&amp;&amp;</span> <span class="n">next</span> <span class="o">==</span> <span class="n">first</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">allStringsEqual</span><span class="p">(</span><span class="n">_</span> <span class="nv">array</span><span class="p">:</span> <span class="p">[</span><span class="kt">String</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="p">{</span>
    <span class="k">guard</span> <span class="k">let</span> <span class="nv">first</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">first</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">false</span> <span class="p">}</span>
    <span class="k">return</span> <span class="n">array</span><span class="o">.</span><span class="nf">reduce</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span> <span class="n">partial</span><span class="p">,</span> <span class="n">next</span> <span class="k">in</span> <span class="n">partial</span> <span class="o">&amp;&amp;</span> <span class="n">next</span> <span class="o">==</span> <span class="n">first</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Both functions have exactly the same code but operate in different types. In order to remove this duplication, we can rewrite the type signature and the implementation could remain the same:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="n">allEqual</span><span class="o">&lt;</span><span class="kt">A</span><span class="p">:</span> <span class="kt">Equatable</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">array</span><span class="p">:</span> <span class="p">[</span><span class="kt">A</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="p">{</span>
    <span class="k">guard</span> <span class="k">let</span> <span class="nv">first</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">first</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">false</span> <span class="p">}</span>
    <span class="k">return</span> <span class="n">array</span><span class="o">.</span><span class="nf">reduce</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span> <span class="n">partial</span><span class="p">,</span> <span class="n">next</span> <span class="k">in</span> <span class="n">partial</span> <span class="o">&amp;&amp;</span> <span class="n">next</span> <span class="o">==</span> <span class="n">first</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Both functions, <code class="highlighter-rouge">allIntsEqual</code> and <code class="highlighter-rouge">allStringsEqual</code> can be replaced by <code class="highlighter-rouge">allEqual</code>, which works for every type <code class="highlighter-rouge">A</code>, as long as this type conforms to <code class="highlighter-rouge">Equatable</code>. <code class="highlighter-rouge">A</code> is known as the <strong>type parameter</strong> and <code class="highlighter-rouge">allEqual</code> is a function that uses <strong>parametric polymorphism</strong>; i.e. it has <em>many forms</em> that depend on the type parameter we use.</p>

<p>This enables a degree of generic programming where we can create families of functions that work on many types as long as they conform to certain protocols. However, this is not expressive enough. Let us consider the following functions:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">enum</span> <span class="kt">DivideError</span><span class="p">:</span> <span class="kt">Error</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">divisionByZero</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">divideEither</span><span class="p">(</span><span class="nv">x</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="nv">y</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Either</span><span class="o">&lt;</span><span class="kt">DivideError</span><span class="p">,</span> <span class="kt">Int</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">guard</span> <span class="n">y</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="o">.</span><span class="nf">left</span><span class="p">(</span><span class="o">.</span><span class="n">divisionByZero</span><span class="p">)</span> <span class="p">}</span>
    <span class="k">return</span> <span class="o">.</span><span class="nf">right</span><span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">y</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">divideValidated</span><span class="p">(</span><span class="nv">x</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="nv">y</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Validated</span><span class="o">&lt;</span><span class="kt">DivideError</span><span class="p">,</span> <span class="kt">Int</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">guard</span> <span class="n">y</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="o">.</span><span class="nf">invalid</span><span class="p">(</span><span class="o">.</span><span class="n">divisionByZero</span><span class="p">)</span> <span class="p">}</span>
    <span class="k">return</span> <span class="o">.</span><span class="nf">valid</span><span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">y</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We can see some similarities between these two functions. They are checking that the second argument is not 0 to perform the division and wrap it in a right/valid case. Otherwise, the division cannot be performed and they wrap an error in a left/invalid case. It would be helpful to unify these two functions in a similar way as in the <code class="highlighter-rouge">allEqual</code> example presented above. Hypothetically, we would like to write something like:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kd">func</span> <span class="n">divide</span><span class="o">&lt;</span><span class="kt">F</span><span class="p">:</span> <span class="kt">ErrorSuccessRepresentable</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">x</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="nv">y</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">F</span><span class="o">&lt;</span><span class="kt">DivideError</span><span class="p">,</span> <span class="kt">Int</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">guard</span> <span class="n">y</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="o">.</span><span class="nf">failure</span><span class="p">(</span><span class="o">.</span><span class="n">divisionByZero</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">.</span><span class="nf">success</span><span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">y</span><span class="p">)</span>
 <span class="p">}</span>
</code></pre></div></div>

<p>That is, given a type <code class="highlighter-rouge">F</code> that is able to create success and error values (via the hypothetical <code class="highlighter-rouge">ErrorSuccessRepresentable</code> protocol), we could write a function that checks if the division can be performed or not, and create the result values accordingly. This would allow us to write generic programs where we can generalize the container types, not only the contained ones.</p>

<p>Unfortunately, Swift does not support writing the code above since it does not have HKTs support. Can we find a workaround to have this feature?</p>

<h2 id="types-and-kinds">Types and Kinds</h2>

<p>Before we answer this question, let us review some basic concepts. The notion of <strong>type</strong> is well-known among software engineers and Swift developers. Being a class, struct or enum, a type is a set of values. This set may be finite, as in the case of <code class="highlighter-rouge">Bool</code> where there are only two values (<code class="highlighter-rouge">true</code> and <code class="highlighter-rouge">false</code>), or infinite, as in the case of <code class="highlighter-rouge">String</code>. Types group values that are similar. If we raise the level of abstraction, we could group similar types in sets of types; those <em>sets of types</em> are <strong>kinds</strong>.</p>

<p>So, how are types grouped into kinds then? Using notation that comes from Haskell, we can group them like:</p>

<ul>
  <li><code class="highlighter-rouge">*</code>: read <em>type</em>, is the kind of types that do not have type parameters. Examples of types of this kind are <code class="highlighter-rouge">Int</code>, <code class="highlighter-rouge">String</code> or <code class="highlighter-rouge">Bool</code>, but not limited to primitive types; developer created types like <code class="highlighter-rouge">User</code> or <code class="highlighter-rouge">UIViewController</code> are also types of this kind.</li>
  <li><code class="highlighter-rouge">* -&gt; *</code>: is the kind of types that receive one type parameter. That includes types which, given a type, can provide another one. Examples of this are <code class="highlighter-rouge">Array&lt;Element&gt;</code> or <code class="highlighter-rouge">Optional&lt;Wrapped&gt;</code>; these types, when provided an <code class="highlighter-rouge">Element</code> or <code class="highlighter-rouge">Wrapped</code> type, will create a new type in the system.</li>
  <li><code class="highlighter-rouge">* -&gt; * -&gt; *</code>: is the kind of types that receive two type parameters. Similar to the case above, examples of this kind are <code class="highlighter-rouge">Result&lt;Value, Error&gt;</code> or <code class="highlighter-rouge">Function1&lt;Input, Output&gt;</code>; when we provide two types to fill their two <em>holes</em>, we get a new type back.</li>
</ul>

<p>We could go on and on. The important thing to notice here is that, whenever we provide a type parameter, the kind of the resulting type changes.</p>

<p>For example, we have mentioned that <code class="highlighter-rouge">Array&lt;Element&gt;</code> is of kind <code class="highlighter-rouge">* -&gt; *</code>. If we provide a type, like <code class="highlighter-rouge">Int</code> or <code class="highlighter-rouge">String</code>, the new type becomes <code class="highlighter-rouge">Array&lt;Int&gt;</code> or <code class="highlighter-rouge">Array&lt;String&gt;</code>, which are of kind <code class="highlighter-rouge">*</code>. Similarly, <code class="highlighter-rouge">Result&lt;Value, Error&gt;</code> is of kind <code class="highlighter-rouge">* -&gt; * -&gt; *</code>, <code class="highlighter-rouge">Result&lt;Int, Error&gt;</code> is of kind <code class="highlighter-rouge">* -&gt; *</code> (still has one type parameter that has not been fixed), and <code class="highlighter-rouge">Result&lt;Int, DivideError&gt;</code> is of kind <code class="highlighter-rouge">*</code>. This means that type constructors can be <strong>partially applied</strong> to obtain new type constructors.</p>

<h2 id="emulating-hkts-in-bow">Emulating HKTs in Bow</h2>

<p>Once we know the limitations of Swift to deal with HKTs and how types are grouped into kinds, we can explore how HKTs can be simulated within the current Swift type system. We mentioned above that we can abstract over the type parameters of a type constructor, but not over the type constructor itself.</p>

<p>Using this information, we created an intermediate structure where instead of working with <code class="highlighter-rouge">F&lt;A&gt;</code>, we work with <code class="highlighter-rouge">Kind&lt;F, A&gt;</code>. <code class="highlighter-rouge">Kind&lt;F, A&gt;</code> represents types of kind <code class="highlighter-rouge">* -&gt; *</code>. We have kinds of higher arities; for instance, <code class="highlighter-rouge">F&lt;A, B&gt;</code> corresponds to <code class="highlighter-rouge">Kind2&lt;F, A, B&gt;</code>, and represents types of kind <code class="highlighter-rouge">* -&gt; * -&gt; *</code>. We can continue up to 10 type arguments.</p>

<p>This is not enough. If you look at the API reference, <code class="highlighter-rouge">Kind</code> is a class and we would need to extend it in order to have HKT support for our type. Let us assume we would like to implement a <code class="highlighter-rouge">Maybe&lt;A&gt;</code> type, behaving like a Swift optional value, with HKT support. We have mentioned above that <code class="highlighter-rouge">F&lt;A&gt;</code> becomes <code class="highlighter-rouge">Kind&lt;F, A&gt;</code>; therefore, <code class="highlighter-rouge">Maybe&lt;A&gt;</code> needs to extend <code class="highlighter-rouge">Kind&lt;Maybe, A&gt;</code>, but this does not compile and has a cycle in the inheritance relationship.</p>

<p>In order to avoid this, an intermediate class is created. This class is called the <strong>witness</strong> and, as a convention in Bow, they are named as the type they support, with the prefix <code class="highlighter-rouge">For</code>. Therefore, our type would be <code class="highlighter-rouge">Maybe&lt;A&gt;: Kind&lt;ForMaybe, A&gt;</code>.</p>

<p>What about HKTs with higher arity? As we mentioned above, when we partially a type parameter, the kind arity gets reduced in one. We use this to have the following equivalences:</p>

<ul>
  <li><code class="highlighter-rouge">Kind2&lt;F, A, B&gt;</code> is equivalent to <code class="highlighter-rouge">Kind&lt;Kind&lt;F, A&gt;, B&gt;</code>.</li>
  <li><code class="highlighter-rouge">Kind3&lt;F, A, B, C&gt;</code> is equivalent to <code class="highlighter-rouge">Kind&lt;Kind2&lt;F, A, B&gt;, C&gt;</code>.</li>
  <li><code class="highlighter-rouge">Kind4&lt;F, A, B, C, D&gt;</code> is equivalent to <code class="highlighter-rouge">Kind&lt;Kind3&lt;F, A, B, C&gt;, D&gt;</code>.</li>
</ul>

<p>And you can continue the series up to <code class="highlighter-rouge">Kind10</code>. This means we can partially apply the types and leave the last type parameter, reducing the arity of the kind by one. This is particularly useful when we are working with type classes that operate on kinds.</p>

<p>So, consider we want to implement an <em>exclusive or</em> type that has a value of either one of two types. As we mentioned above, we need a witness class for it:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">final</span> <span class="kd">class</span> <span class="kt">ForXor</span> <span class="p">{}</span>
</code></pre></div></div>

<p>For types that have more than one type parameter, it is convenient to write an intermediate type with a partial application:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">final</span> <span class="kd">class</span> <span class="kt">XorPartial</span><span class="o">&lt;</span><span class="kt">Left</span><span class="o">&gt;</span><span class="p">:</span> <span class="kt">Kind</span><span class="o">&lt;</span><span class="kt">ForXor</span><span class="p">,</span> <span class="kt">Left</span><span class="o">&gt;</span> <span class="p">{}</span>
</code></pre></div></div>

<p>And finally, for the sake of readability, we usually create a type alias, named as the type with the suffix <code class="highlighter-rouge">Of</code>:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">typealias</span> <span class="kt">XorOf</span><span class="o">&lt;</span><span class="kt">Left</span><span class="p">,</span> <span class="kt">Right</span><span class="o">&gt;</span> <span class="o">=</span> <span class="kt">Kind</span><span class="o">&lt;</span><span class="kt">XorPartial</span><span class="o">&lt;</span><span class="kt">Left</span><span class="o">&gt;</span><span class="p">,</span> <span class="kt">Right</span><span class="o">&gt;</span>
</code></pre></div></div>

<p>Our exclusive or type can be defined now as:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">Xor</span><span class="o">&lt;</span><span class="kt">Left</span><span class="p">,</span> <span class="kt">Right</span><span class="o">&gt;</span><span class="p">:</span> <span class="kt">XorOf</span><span class="o">&lt;</span><span class="kt">Left</span><span class="p">,</span> <span class="kt">Right</span><span class="o">&gt;</span> <span class="p">{}</span>
</code></pre></div></div>

<p>These 4 lines will give our type the capability of being used as a HKT. It involves writing some boilerplate code that we are working to automate. Bow data types already support this, so you do not need to worry about it; in case you need to write your own types with HKT support, you can follow the process above.</p>

<p>The following table summarizes the HKT support for some data types in the core module:</p>

<table>
  <thead>
    <tr>
      <th>Data type</th>
      <th>Witness</th>
      <th>Partial application</th>
      <th>Type alias</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Function0<a></a></td>
      <td>ForFunction0</td>
      <td> </td>
      <td>Function0Of<a></a></td>
    </tr>
    <tr>
      <td>Function1&lt;I, O&gt;</td>
      <td>ForFunction1</td>
      <td>Function1Partial<i></i></td>
      <td>Function1Of&lt;I, O&gt;</td>
    </tr>
    <tr>
      <td>ArrayK<a></a></td>
      <td>ForArrayK</td>
      <td> </td>
      <td>ArrayKOf<a></a></td>
    </tr>
    <tr>
      <td>Const&lt;A, T&gt;</td>
      <td>ForConst</td>
      <td>ConstPartial<a></a></td>
      <td>ConstOf&lt;A, T&gt;</td>
    </tr>
    <tr>
      <td>Either&lt;L, R&gt;</td>
      <td>ForEither</td>
      <td>EitherPartial<L></L></td>
      <td>EitherOf&lt;L, R&gt;</td>
    </tr>
    <tr>
      <td>Id<a></a></td>
      <td>ForId</td>
      <td> </td>
      <td>IdOf<a></a></td>
    </tr>
    <tr>
      <td>Ior&lt;L, R&gt;</td>
      <td>ForIor</td>
      <td>IorPartial<L></L></td>
      <td>IorOf&lt;L, R&gt;</td>
    </tr>
    <tr>
      <td>NonEmptyArray<a></a></td>
      <td>ForNonEmptyArray</td>
      <td> </td>
      <td>NonEmptyArrayOf<a></a></td>
    </tr>
    <tr>
      <td>Option<a></a></td>
      <td>ForOption</td>
      <td> </td>
      <td>OptionOf<a></a></td>
    </tr>
    <tr>
      <td>Try<a></a></td>
      <td>ForTry</td>
      <td> </td>
      <td>TryOf<a></a></td>
    </tr>
    <tr>
      <td>Validated&lt;E, A&gt;</td>
      <td>ForValidated</td>
      <td>ValidatedPartial<E></E></td>
      <td>ValidatedOf&lt;E, A&gt;</td>
    </tr>
  </tbody>
</table>

<h3 id="casting-and-the--operator">Casting and the ^ operator</h3>

<p>We have established a 1 to 1 relationship between <code class="highlighter-rouge">F&lt;A&gt;</code> and <code class="highlighter-rouge">Kind&lt;ForF, A&gt;</code>, but the compiler does not have a way to enforce it. Therefore, there are situations where operating with a HKT can return us a value of type <code class="highlighter-rouge">Kind&lt;ForF, A&gt;</code> instead of the <code class="highlighter-rouge">F&lt;A&gt;</code> type that we are expecting. Since we know our type is the only class extending <code class="highlighter-rouge">Kind&lt;ForF, A&gt;</code> we can do a force cast to obtain our concrete type.</p>

<p>Bow types include a static method <code class="highlighter-rouge">fix</code> that does this. We can extend our <code class="highlighter-rouge">Xor</code> type above to have it:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">extension</span> <span class="kt">Xor</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="kd">func</span> <span class="nf">fix</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">XorOf</span><span class="o">&lt;</span><span class="kt">Left</span><span class="p">,</span> <span class="kt">Right</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Xor</span><span class="o">&lt;</span><span class="kt">Left</span><span class="p">,</span> <span class="kt">Right</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">value</span> <span class="k">as!</span> <span class="kt">Xor</span><span class="o">&lt;</span><span class="kt">Left</span><span class="p">,</span> <span class="kt">Right</span><span class="o">&gt;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>To simplify things even further, Bow has introduced the <code class="highlighter-rouge">^</code> postfix operator, that calls <code class="highlighter-rouge">fix</code> to avoid boilerplate. In our example:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">postfix</span> <span class="kd">func</span> <span class="o">^&lt;</span><span class="kt">A</span><span class="p">,</span> <span class="kt">B</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">XorOf</span><span class="o">&lt;</span><span class="kt">A</span><span class="p">,</span> <span class="kt">B</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Xor</span><span class="o">&lt;</span><span class="kt">A</span><span class="p">,</span> <span class="kt">B</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kt">Xor</span><span class="o">.</span><span class="nf">fix</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This operator can be used with any of the existing types in Bow and lets us chain method calls in a similar manner as we do with the <code class="highlighter-rouge">?.</code> operator. For instance, consider the <code class="highlighter-rouge">Either</code> type and its <code class="highlighter-rouge">map</code> combinator. <code class="highlighter-rouge">map</code> is defined to operate at the kind level, so an invocation to this combinator returns something of type <code class="highlighter-rouge">Kind</code>, instead of <code class="highlighter-rouge">Either</code>.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">either</span> <span class="o">=</span> <span class="kt">Either</span><span class="o">&lt;</span><span class="kt">DivideError</span><span class="p">,</span> <span class="kt">Int</span><span class="o">&gt;.</span><span class="nf">right</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">toString</span> <span class="o">=</span> <span class="n">either</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">value</span> <span class="k">in</span> <span class="n">value</span><span class="o">.</span><span class="n">description</span> <span class="p">}</span> <span class="c1">// toString is of type Kind&lt;EitherPartial&lt;DivideError&gt;, String</span>
</code></pre></div></div>

<p>We can continue chaining methods to this value as long as they are defined for <code class="highlighter-rouge">Kind</code>, but if we would like to use some method specific for <code class="highlighter-rouge">Either</code>, the compiler does not know about the 1 to 1 correspondence we stablished for the types and we need to cast. We can use the fix method:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">fixedToString</span> <span class="o">=</span> <span class="kt">Either</span><span class="o">.</span><span class="nf">fix</span><span class="p">(</span><span class="n">toString</span><span class="p">)</span> <span class="c1">// fixedToString is of type Either&lt;DivideError, String&gt;</span>
</code></pre></div></div>

<p>Or we can use the operator to reduce boilerplate:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">fixedToString2</span> <span class="o">=</span> <span class="n">toString</span><span class="o">^</span>
</code></pre></div></div>

<p>The operator becomes much more convenient when chaining methods. For instance, the <code class="highlighter-rouge">swap</code> method is defined in <code class="highlighter-rouge">Either</code> and not available in <code class="highlighter-rouge">Kind</code>; therefore, we need to cast:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">swapped</span> <span class="o">=</span> <span class="n">either</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">value</span> <span class="k">in</span> <span class="n">value</span><span class="o">.</span><span class="n">description</span> <span class="p">}</span><span class="o">^.</span><span class="nf">swap</span><span class="p">()</span> <span class="c1">// swapped is of type Either&lt;String, DivideError&gt;</span>
</code></pre></div></div>

<h2 id="hkt-support-for-existing-types">HKT support for existing types</h2>

<p>Previous sections have covered how to create a new type with HKT support. However, there are a number of types that are already created and probably outside our control. How do we add HKT support for them?</p>

<p>Unfortunately, there is no way to do this out of the box using the mechanisms that Swift provides for extensions. The solution that we have adopted is to wrap the existing type into another type with HKT support, and delegate methods to the internal wrapped value.</p>

<p>Thus, you can see some types in Bow that have a <code class="highlighter-rouge">K</code> at the end. This indicates the type is a wrapper over another type, adding HKT support. The following table summarizes some of the types that we have added this kind of support.</p>

<table>
  <thead>
    <tr>
      <th>Bow type</th>
      <th>Defined in module</th>
      <th>Original type</th>
      <th>From library</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>ArrayK</td>
      <td>Bow</td>
      <td>Array</td>
      <td> </td>
    </tr>
    <tr>
      <td>DictionaryK</td>
      <td>Bow</td>
      <td>Dictionary</td>
      <td> </td>
    </tr>
    <tr>
      <td>SetK</td>
      <td>Bow</td>
      <td>Set</td>
      <td> </td>
    </tr>
    <tr>
      <td>FutureK</td>
      <td>BowBrightFutures</td>
      <td>Future</td>
      <td>BrightFutures</td>
    </tr>
    <tr>
      <td>MaybeK</td>
      <td>BowRx</td>
      <td>Maybe</td>
      <td>RxSwift</td>
    </tr>
    <tr>
      <td>ObservableK</td>
      <td>BowRx</td>
      <td>Observable</td>
      <td>RxSwift</td>
    </tr>
    <tr>
      <td>SingleK</td>
      <td>BowRx</td>
      <td>Single</td>
      <td>RxSwift</td>
    </tr>
  </tbody>
</table>

    </div>
</div>

</div>
<!-- Custom scripts for this template -->
<script src="/0.4.0/js/docs.js"></script>
<!-- Gitter -->
<script>
  ((window.gitter = {}).chat = {}).options = {
    room: 'bowswift/bow'
  };
</script>
<script src="https://sidecar.gitter.im/dist/sidecar.v1.js" async defer></script>

</body>
</html>
